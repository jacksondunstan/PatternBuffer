
using System;
using System.IO;
using System.Runtime.Serialization;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using com.calitha.goldparser;
using com.calitha.commons;

/*
 * The outline of this file was generated by the GOLD parser desktop application, then fully
 * implemented to create the necessary run-time objects.
 * 
 * Changing the schema in any significant way will require regeneration of the outline and a
 * merge with this implementation to sort out disagreements.
 */

namespace PatternBuffer.Schema {

    [Serializable()]
    public class SymbolException : System.Exception {
        public SymbolException(string message) : base(message) {
        }

        public SymbolException(string message,
            Exception inner) : base(message, inner) {
        }

        protected SymbolException(SerializationInfo info,
            StreamingContext context) : base(info, context) {
        }

    }

    [Serializable()]
    public class RuleException : System.Exception {

        public RuleException(string message) : base(message) {
        }

        public RuleException(string message,
                             Exception inner) : base(message, inner) {
        }

        protected RuleException(SerializationInfo info,
                                StreamingContext context) : base(info, context) {
        }

    }

    enum SymbolConstants : int {
        SYMBOL_EOF = 0, // (EOF)
        SYMBOL_ERROR = 1, // (Error)
        SYMBOL_COMMENT = 2, // Comment
        SYMBOL_NEWLINE = 3, // NewLine
        SYMBOL_WHITESPACE = 4, // Whitespace
        SYMBOL_TIMESDIV = 5, // '*/'
        SYMBOL_DIVTIMES = 6, // '/*'
        SYMBOL_DIVDIV = 7, // '//'
        SYMBOL_LPAREN = 8, // '('
        SYMBOL_RPAREN = 9, // ')'
        SYMBOL_COMMA = 10, // ','
        SYMBOL_COLON = 11, // ':'
        SYMBOL_SEMI = 12, // ';'
        SYMBOL_LBRACKET = 13, // '['
        SYMBOL_RBRACKET = 14, // ']'
        SYMBOL_LBRACE = 15, // '{'
        SYMBOL_RBRACE = 16, // '}'
        SYMBOL_LT = 17, // '<'
        SYMBOL_EQ = 18, // '='
        SYMBOL_GT = 19, // '>'
        SYMBOL_ENUM = 20, // enum
        SYMBOL_HINTNAME = 21, // HintName
        SYMBOL_LIST = 22, // list
        SYMBOL_MAP = 23, // map
        SYMBOL_NAME = 24, // Name
        SYMBOL_PRIMITIVE = 25, // Primitive
        SYMBOL_SET = 26, // set
        SYMBOL_STRING = 27, // String
        SYMBOL_TYPE = 28, // type
        SYMBOL_TYPEID = 29, // TypeId
        SYMBOL_AGGREGATEARG = 30, // <AggregateArg>
        SYMBOL_BASETYPE = 31, // <BaseType>
        SYMBOL_BASETYPENAME = 32, // <BaseTypeName>
        SYMBOL_ENUM2 = 33, // <Enum>
        SYMBOL_ENUMNAME = 34, // <EnumName>
        SYMBOL_ENUMVALUE = 35, // <EnumValue>
        SYMBOL_FIELDNAME = 36, // <FieldName>
        SYMBOL_HINT = 37, // <Hint>
        SYMBOL_HINTNAME2 = 38, // <HintName>
        SYMBOL_HINTVALUE = 39, // <HintValue>
        SYMBOL_LISTFIELD = 40, // <ListField>
        SYMBOL_MAPFIELD = 41, // <MapField>
        SYMBOL_PRIMITIVEFIELD = 42, // <PrimitiveField>
        SYMBOL_PRIMITIVEFIELDTYPE = 43, // <PrimitiveFieldType>
        SYMBOL_REFERENCEFIELD = 44, // <ReferenceField>
        SYMBOL_REFERENCEFIELDTYPE = 45, // <ReferenceFieldType>
        SYMBOL_SCHEMA = 46, // <Schema>
        SYMBOL_SCHEMAELEMENT = 47, // <SchemaElement>
        SYMBOL_SCHEMANAME = 48, // <SchemaName>
        SYMBOL_SCHEMANAMEELEMENT = 49, // <SchemaNameElement>
        SYMBOL_SETFIELD = 50, // <SetField>
        SYMBOL_TYPE2 = 51, // <Type>
        SYMBOL_TYPEFIELD = 52, // <TypeField>
        SYMBOL_TYPEID2 = 53, // <TypeId>
        SYMBOL_TYPENAME = 54  // <TypeName>
    };

    enum RuleConstants : int {
        RULE_SCHEMA = 0, // <Schema> ::= <SchemaNameElement> <Hint> <SchemaElement>
        RULE_SCHEMANAMEELEMENT_NAME_SEMI = 1, // <SchemaNameElement> ::= Name <SchemaName> ';'
        RULE_SCHEMANAME_NAME = 2, // <SchemaName> ::= Name
        RULE_SCHEMAELEMENT = 3, // <SchemaElement> ::= <Type> <SchemaElement>
        RULE_SCHEMAELEMENT2 = 4, // <SchemaElement> ::= <Enum> <SchemaElement>
        RULE_SCHEMAELEMENT3 = 5, // <SchemaElement> ::= 
        RULE_BASETYPE_COLON = 6, // <BaseType> ::= ':' <BaseTypeName>
        RULE_BASETYPE = 7, // <BaseType> ::= 
        RULE_BASETYPENAME_NAME = 8, // <BaseTypeName> ::= Name
        RULE_TYPE_TYPE_LPAREN_RPAREN_LBRACE_RBRACE = 9, // <Type> ::= type '(' <TypeId> ')' <TypeName> <BaseType> '{' <Hint> <TypeField> '}'
        RULE_TYPENAME_NAME = 10, // <TypeName> ::= Name
        RULE_TYPEID_TYPEID = 11, // <TypeId> ::= TypeId
        RULE_TYPEID = 12, // <TypeId> ::= 
        RULE_TYPEFIELD = 13, // <TypeField> ::= <PrimitiveField> <TypeField>
        RULE_TYPEFIELD2 = 14, // <TypeField> ::= <ReferenceField> <TypeField>
        RULE_TYPEFIELD3 = 15, // <TypeField> ::= <ListField> <TypeField>
        RULE_TYPEFIELD4 = 16, // <TypeField> ::= <SetField> <TypeField>
        RULE_TYPEFIELD5 = 17, // <TypeField> ::= <MapField> <TypeField>
        RULE_TYPEFIELD6 = 18, // <TypeField> ::= 
        RULE_PRIMITIVEFIELD_SEMI = 19, // <PrimitiveField> ::= <PrimitiveFieldType> <FieldName> ';'
        RULE_PRIMITIVEFIELDTYPE_PRIMITIVE = 20, // <PrimitiveFieldType> ::= Primitive
        RULE_REFERENCEFIELD_SEMI = 21, // <ReferenceField> ::= <ReferenceFieldType> <FieldName> ';'
        RULE_REFERENCEFIELDTYPE_NAME = 22, // <ReferenceFieldType> ::= Name
        RULE_FIELDNAME_NAME = 23, // <FieldName> ::= Name
        RULE_LISTFIELD_LIST_LT_GT_SEMI = 24, // <ListField> ::= list '<' <AggregateArg> '>' <FieldName> ';'
        RULE_SETFIELD_SET_LT_GT_SEMI = 25, // <SetField> ::= set '<' <AggregateArg> '>' <FieldName> ';'
        RULE_MAPFIELD_MAP_LT_COMMA_GT_SEMI = 26, // <MapField> ::= map '<' <AggregateArg> ',' <AggregateArg> '>' <FieldName> ';'
        RULE_AGGREGATEARG = 27, // <AggregateArg> ::= <PrimitiveFieldType>
        RULE_AGGREGATEARG2 = 28, // <AggregateArg> ::= <ReferenceFieldType>
        RULE_ENUM_ENUM_LBRACE_RBRACE = 29, // <Enum> ::= enum <EnumName> '{' <Hint> <EnumValue> '}'
        RULE_ENUMNAME_NAME = 30, // <EnumName> ::= Name
        RULE_ENUMVALUE_NAME = 31, // <EnumValue> ::= Name
        RULE_ENUMVALUE_NAME_COMMA = 32, // <EnumValue> ::= Name ',' <EnumValue>
        RULE_HINT_LBRACKET_EQ_RBRACKET = 33, // <Hint> ::= '[' <HintName> '=' <HintValue> ']' <Hint>
        RULE_HINT = 34, // <Hint> ::= 
        RULE_HINTNAME_HINTNAME = 35, // <HintName> ::= HintName
        RULE_HINTVALUE_STRING = 36  // <HintValue> ::= String
    };

    public class PatternBufferSchemaParser {
        private LALRParser parser;
        private List<string> lowerCasePrimitiveTypeEnumValues;
        private string error;

        public PatternBufferSchemaParser(string filename) {
            FileStream stream = new FileStream(filename,
                                               FileMode.Open,
                                               FileAccess.Read,
                                               FileShare.Read);
            Init(stream);
            stream.Close();
        }

        public PatternBufferSchemaParser() {
            Stream stream = System.Reflection.Assembly.GetExecutingAssembly().GetManifestResourceStream("PatternBuffer.Schema.Resources.PatternBuffer.cgt");
            Init(stream);
            stream.Close();
        }

        public PatternBufferSchemaParser(Stream stream) {
            Init(stream);
        }

        private void Init(Stream stream) {
            CGTReader reader = new CGTReader(stream);
            parser = reader.CreateNewParser();
            parser.TrimReductions = false;
            parser.StoreTokens = LALRParser.StoreTokensMode.NoUserObject;

            parser.OnTokenError += new LALRParser.TokenErrorHandler(TokenErrorEvent);
            parser.OnParseError += new LALRParser.ParseErrorHandler(ParseErrorEvent);

            this.lowerCasePrimitiveTypeEnumValues = new List<string>();
            foreach (PrimitiveType pt in Enum.GetValues(typeof(PrimitiveType))) {
                lowerCasePrimitiveTypeEnumValues.Add(pt.ToString().ToLower());
            }
            this.error = null;
        }

        public PatternBufferSchema Parse(string source) {
            NonterminalToken token = parser.Parse(source);
            PatternBufferSchema schema = null;
            if (this.error == null && token != null) {
                schema = (PatternBufferSchema)CreateObject(token);
            }
            if (this.error != null) {
                throw new PatternBufferSchemaException(this.error);
            }
            return schema;
        }

        private Object CreateObject(Token token) {
            if (token is TerminalToken)
                return CreateObjectFromTerminal((TerminalToken)token);
            else
                return CreateObjectFromNonterminal((NonterminalToken)token);
        }

        private Object CreateObjectFromTerminal(TerminalToken token) {
            switch (token.Symbol.Id) {
                case (int)SymbolConstants.SYMBOL_EOF:
                    //(EOF)
                    return null;

                case (int)SymbolConstants.SYMBOL_ERROR:
                    //(Error)
                    return null;

                case (int)SymbolConstants.SYMBOL_COMMENT:
                    //Comment
                    return null;

                case (int)SymbolConstants.SYMBOL_NEWLINE:
                    //NewLine
                    return null;

                case (int)SymbolConstants.SYMBOL_WHITESPACE:
                    //Whitespace
                    return null;

                case (int)SymbolConstants.SYMBOL_TIMESDIV:
                    //'*/'
                    return null;

                case (int)SymbolConstants.SYMBOL_DIVTIMES:
                    //'/*'
                    return null;

                case (int)SymbolConstants.SYMBOL_DIVDIV:
                    //'//'
                    return null;

                case (int)SymbolConstants.SYMBOL_LPAREN:
                    //'('
                    return null;

                case (int)SymbolConstants.SYMBOL_RPAREN:
                    //')'
                    return null;

                case (int)SymbolConstants.SYMBOL_COMMA:
                    //','
                    return null;

                case (int)SymbolConstants.SYMBOL_COLON:
                    //':'
                    return null;

                case (int)SymbolConstants.SYMBOL_SEMI:
                    //';'
                    return null;

                case (int)SymbolConstants.SYMBOL_LBRACKET:
                    //'['
                    return null;

                case (int)SymbolConstants.SYMBOL_RBRACKET:
                    //']'
                    return null;

                case (int)SymbolConstants.SYMBOL_LBRACE:
                    //'{'
                    return null;

                case (int)SymbolConstants.SYMBOL_RBRACE:
                    //'}'
                    return null;

                case (int)SymbolConstants.SYMBOL_LT:
                    //'<'
                    return null;

                case (int)SymbolConstants.SYMBOL_EQ:
                    //'='
                    return null;

                case (int)SymbolConstants.SYMBOL_GT:
                    //'>'
                    return null;

                case (int)SymbolConstants.SYMBOL_ENUM:
                    //enum
                    return null;

                case (int)SymbolConstants.SYMBOL_HINTNAME:
                    //HintName
                    return token.Text;

                case (int)SymbolConstants.SYMBOL_LIST:
                    //list
                    return null;

                case (int)SymbolConstants.SYMBOL_MAP:
                    //map
                    return null;

                case (int)SymbolConstants.SYMBOL_NAME:
                    //Name
                    return token.Text;

                case (int)SymbolConstants.SYMBOL_PRIMITIVE:
                    //Primitive
                    return token.Text;

                case (int)SymbolConstants.SYMBOL_SET:
                    //set
                    return null;

                case (int)SymbolConstants.SYMBOL_STRING:
                    //String
                    string text = token.Text;
                    // Pull the quotes off
                    text = text.Substring(1, text.Length - 2);
                    // Unescape any escape sequences (e.g. backslash "n" for new line)
                    text = Regex.Unescape(text);
                    return text;

                case (int)SymbolConstants.SYMBOL_TYPE:
                    //type
                    return null;

                case (int)SymbolConstants.SYMBOL_TYPEID:
                    //TypeId
                    return token.Text != null ?
                        ushort.Parse(token.Text) :
                        (ushort)0;

                case (int)SymbolConstants.SYMBOL_AGGREGATEARG:
                    //<AggregateArg>
                    return token.Text;

                case (int)SymbolConstants.SYMBOL_BASETYPE:
                    //<BaseType>
                    return token.Text;

                case (int)SymbolConstants.SYMBOL_BASETYPENAME:
                    //<BaseTypeName>
                    return token.Text;

                case (int)SymbolConstants.SYMBOL_ENUM2:
                    //<Enum>
                    return null;

                case (int)SymbolConstants.SYMBOL_ENUMNAME:
                    //<EnumName>
                    return token.Text;

                case (int)SymbolConstants.SYMBOL_ENUMVALUE:
                    //<EnumValue>
                    return token.Text;

                case (int)SymbolConstants.SYMBOL_FIELDNAME:
                    //<FieldName>
                    return token.Text;

                case (int)SymbolConstants.SYMBOL_HINT:
                    //<Hint>
                    return null;

                case (int)SymbolConstants.SYMBOL_HINTNAME2:
                    //<HintName>
                    return token.Text;

                case (int)SymbolConstants.SYMBOL_HINTVALUE:
                    //<HintValue>
                    return token.Text;

                case (int)SymbolConstants.SYMBOL_LISTFIELD:
                    //<ListField>
                    return null;

                case (int)SymbolConstants.SYMBOL_MAPFIELD:
                    //<MapField>
                    return null;

                case (int)SymbolConstants.SYMBOL_PRIMITIVEFIELD:
                    //<PrimitiveField>
                    return null;

                case (int)SymbolConstants.SYMBOL_PRIMITIVEFIELDTYPE:
                    //<PrimitiveFieldType>
                    return token.Text;

                case (int)SymbolConstants.SYMBOL_REFERENCEFIELD:
                    //<ReferenceField>
                    return null;

                case (int)SymbolConstants.SYMBOL_REFERENCEFIELDTYPE:
                    //<ReferenceFieldType>
                    return token.Text;

                case (int)SymbolConstants.SYMBOL_SCHEMA:
                    //<Schema>
                    return null;

                case (int)SymbolConstants.SYMBOL_SCHEMAELEMENT:
                    //<SchemaElement>
                    return null;

                case (int)SymbolConstants.SYMBOL_SCHEMANAME:
                    //<SchemaName>
                    return token.Text;

                case (int)SymbolConstants.SYMBOL_SCHEMANAMEELEMENT:
                    //<SchemaNameElement>
                    return null;

                case (int)SymbolConstants.SYMBOL_SETFIELD:
                    //<SetField>
                    return null;

                case (int)SymbolConstants.SYMBOL_TYPE2:
                    //<Type>
                    return null;

                case (int)SymbolConstants.SYMBOL_TYPEFIELD:
                    //<TypeField>
                    return null;

                case (int)SymbolConstants.SYMBOL_TYPEID2:
                    //<TypeId>
                    return token.Text;

                case (int)SymbolConstants.SYMBOL_TYPENAME:
                    //<TypeName>
                    return token.Text;

            }
            throw new SymbolException("Unknown symbol");
        }

        public Object CreateObjectFromNonterminal(NonterminalToken token) {

            // Delve the tree
            foreach (Token t in token.Tokens) {
                t.UserObject = CreateObject(t);
            }

            switch (token.Rule.Id) {
                case (int)RuleConstants.RULE_SCHEMA:
                    //<Schema> ::= <SchemaNameElement> <SchemaElements>

                    // This is actually the home stretch, even though it comes first. 
                    // It pulls together everything gathered thus far and creates the actual schema object
                    // we want in the end.

                    //DumpTree(token);

                    // Schema name
                    string schemaName = token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_SCHEMANAMEELEMENT);

                    // Schema hints
                    Dictionary<string, string> hints = token.GetUserObjectForSubToken<Dictionary<string, string>>((int)SymbolConstants.SYMBOL_HINT);

                    // Schema elements
                    List<PatternBufferType> types = new List<PatternBufferType>();
                    Dictionary<string,PatternBufferType> nameTypeMap = new Dictionary<string,PatternBufferType>();
                    List<PatternBufferEnum> enums = new List<PatternBufferEnum>();
                    Dictionary<string, PatternBufferEnum> nameEnumMap = new Dictionary<string, PatternBufferEnum>();

                    List<IPatternBufferReferrable> schemaElements = token.GetUserObjectForSubToken<List<IPatternBufferReferrable>>((int)SymbolConstants.SYMBOL_SCHEMAELEMENT);
                    List<string> names = new List<string>();
                    List<ushort> typeIds = new List<ushort>();
                    List<PatternBufferField> referenceFields = new List<PatternBufferField>();
                    
                    // Index all the schema elements
                    foreach (IPatternBufferReferrable schemaElement in schemaElements) {
                        if (names.Contains(schemaElement.Name)) {
                            throw new PatternBufferSchemaException("The name \"" + schemaElement.Name + "\" is duplicated. Type and enum names must be unique.");
                        }
                        names.Add(schemaElement.Name);
                        if (schemaElement is PatternBufferEnum) {
                            PatternBufferEnum e = (PatternBufferEnum)schemaElement;
                            enums.Add(e);
                            nameEnumMap[e.Name] = e;
                        }
                        else if (schemaElement is PatternBufferType) {
                            PatternBufferType type = (PatternBufferType)schemaElement;
                            if (type.TypeId > 0) {
                                if (typeIds.Contains(type.TypeId)) {
                                    throw new PatternBufferSchemaException("Multiple types map to type ID " + type.TypeId + ". Type IDs must be unique.");
                                }
                                typeIds.Add(type.TypeId);
                            }
                            types.Add(type);
                            nameTypeMap[type.Name] = type;
                            foreach (PatternBufferField f in type.Fields) {
                                if (f .FieldType is ReferenceFieldType) {
                                    referenceFields.Add((PatternBufferField)f);
                                }
                            }
                        }
                    }

                    // Bundle up all referrables
                    Dictionary<string, IPatternBufferReferrable> nameReferrableMap = new Dictionary<string, IPatternBufferReferrable>();
                    foreach (PatternBufferEnum allEnum in enums) {
                        nameReferrableMap[allEnum.name] = allEnum;
                    }
                    foreach (PatternBufferType allType in types) {
                        nameReferrableMap[allType.name] = allType;
                    }

                    // Validate name
                    if (schemaName == null) {
                        throw new PatternBufferSchemaException("No schema name is specified. A schema name is required.");
                    }

                    // Validate type hierarchy (no circuits, classes exist)
                    Dictionary<string, List<string>> typeNameFieldNamesMap = new Dictionary<string, List<string>>();
                    foreach (PatternBufferType type in types) {

                        // Validate the type 
                        this.ValidateType(type, nameReferrableMap, nameTypeMap, nameEnumMap);

                        // Set the base type
                        if (type.baseTypeName != null) {
                            type.baseType = nameTypeMap[type.baseTypeName];
                        }
                    }

                    // Set final attribute on all types with no derivatives.
                    foreach (PatternBufferType type in types) {
                        type.isFinal = true;
                        foreach (PatternBufferType otherType in types) {
                            // If any type claims the current type as a base type, it's not final.
                            // This will inform our list/set/map serialization code to minimize type ID duplication.
                            if (type != otherType && otherType.baseType == type) {
                                type.isFinal = false;
                                break;
                            }
                        }
                    }

                    // Create and return
                    PatternBufferSchema schema = new PatternBufferSchema(
                        schemaName,
                        types,
                        enums,
                        hints
                    );
                    return schema;

                case (int)RuleConstants.RULE_SCHEMANAMEELEMENT_NAME_SEMI:
                    //<SchemaNameElement> ::= Name <SchemaName> ';'
                    return token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_SCHEMANAME);

                case (int)RuleConstants.RULE_SCHEMANAME_NAME:
                    //<SchemaName> ::= Name
                    return token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_NAME);

                case (int)RuleConstants.RULE_SCHEMAELEMENT:
                    //<SchemaElement> ::= <Type> <SchemaElement>
                    List<IPatternBufferReferrable> schemaElements2 = token.GetUserObjectForSubToken<List<IPatternBufferReferrable>>((int)SymbolConstants.SYMBOL_SCHEMAELEMENT);
                    PatternBufferType t = token.GetUserObjectForSubToken<PatternBufferType>((int)SymbolConstants.SYMBOL_TYPE2);
                    schemaElements2.Insert(0, t);
                    return schemaElements2;

                case (int)RuleConstants.RULE_SCHEMAELEMENT2:
                    //<SchemaElement> ::= <Enum> <SchemaElement>
                    schemaElements = token.GetUserObjectForSubToken<List<IPatternBufferReferrable>>((int)SymbolConstants.SYMBOL_SCHEMAELEMENT);
                    schemaElements.Insert(0, token.GetUserObjectForSubToken<PatternBufferEnum>((int)SymbolConstants.SYMBOL_ENUM2));
                    return schemaElements;

                case (int)RuleConstants.RULE_SCHEMAELEMENT3:
                    //<SchemaElement> ::= 
                    return new List<IPatternBufferReferrable>();

                case (int)RuleConstants.RULE_BASETYPE_COLON:
                    //<BaseType> ::= ':' <BaseTypeName>
                    return token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_BASETYPENAME);

                case (int)RuleConstants.RULE_BASETYPE:
                    //<BaseType> ::= 
                    return null;

                case (int)RuleConstants.RULE_BASETYPENAME_NAME:
                    //<BaseTypeName> ::= Name
                    return token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_NAME);

                case (int)RuleConstants.RULE_TYPE_TYPE_LPAREN_RPAREN_LBRACE_RBRACE:
                    //<Type> ::= type '(' <TypeId> ')' <TypeName> <BaseType> '{' <Hint> <TypeField> '}'
                    ushort typeId = token.GetUserObjectForSubToken<ushort>((int)SymbolConstants.SYMBOL_TYPEID2);
                    string typeName = token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_TYPENAME);
                    string baseTypeName = token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_BASETYPE);
                    Dictionary<string, string> typeHints = token.GetUserObjectForSubToken<Dictionary<string,string>>((int)SymbolConstants.SYMBOL_HINT);;
                    IList<PatternBufferField> typeFields = token.GetUserObjectForSubToken<IList<PatternBufferField>>((int)SymbolConstants.SYMBOL_TYPEFIELD);
                    return new PatternBufferType(
                        typeName,
                        typeId,
                        typeFields,
                        typeHints,
                        baseTypeName
                    );

                case (int)RuleConstants.RULE_TYPENAME_NAME:
                    //<TypeName> ::= Name
                    return token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_NAME);

                case (int)RuleConstants.RULE_TYPEID_TYPEID:
                    //<TypeId> ::= TypeId
                    return token.GetUserObjectForSubToken<ushort>((int)SymbolConstants.SYMBOL_TYPEID);

                case (int)RuleConstants.RULE_TYPEID:
                    //<TypeId> ::= 
                    return (ushort)0;

                case (int)RuleConstants.RULE_TYPEFIELD:
                    //<TypeField> ::= <PrimitiveField> <TypeField>
                    IList<PatternBufferField> fields1 = token.GetUserObjectForSubToken<IList<PatternBufferField>>((int)SymbolConstants.SYMBOL_TYPEFIELD);
                    PatternBufferField primitiveField = token.GetUserObjectForSubToken<PatternBufferField>((int)SymbolConstants.SYMBOL_PRIMITIVEFIELD);
                    fields1.Insert(0, primitiveField);
                    return fields1;

                case (int)RuleConstants.RULE_TYPEFIELD2:
                    //<TypeField> ::= <ReferenceField> <TypeField>
                    IList<PatternBufferField> fields2 = token.GetUserObjectForSubToken<IList<PatternBufferField>>((int)SymbolConstants.SYMBOL_TYPEFIELD);
                    PatternBufferField referenceField = token.GetUserObjectForSubToken<PatternBufferField>((int)SymbolConstants.SYMBOL_REFERENCEFIELD);
                    fields2.Insert(0, referenceField);
                    return fields2;

                case (int)RuleConstants.RULE_TYPEFIELD3:
                    //<TypeField> ::= <ListField> <TypeField>
                    IList<PatternBufferField> fields3 = token.GetUserObjectForSubToken<IList<PatternBufferField>>((int)SymbolConstants.SYMBOL_TYPEFIELD);
                    PatternBufferField listField = token.GetUserObjectForSubToken<PatternBufferField>((int)SymbolConstants.SYMBOL_LISTFIELD);
                    fields3.Insert(0, listField);
                    return fields3;

                case (int)RuleConstants.RULE_TYPEFIELD4:
                    //<TypeField> ::= <SetField> <TypeField>
                    IList<PatternBufferField> fields4 = token.GetUserObjectForSubToken<IList<PatternBufferField>>((int)SymbolConstants.SYMBOL_TYPEFIELD);
                    PatternBufferField setField = token.GetUserObjectForSubToken<PatternBufferField>((int)SymbolConstants.SYMBOL_SETFIELD);
                    fields4.Insert(0, setField);
                    return fields4;

                case (int)RuleConstants.RULE_TYPEFIELD5:
                    //<TypeField> ::= <MapField> <TypeField>
                    IList<PatternBufferField> fields5 = token.GetUserObjectForSubToken<IList<PatternBufferField>>((int)SymbolConstants.SYMBOL_TYPEFIELD);
                    PatternBufferField mapField = token.GetUserObjectForSubToken<PatternBufferField>((int)SymbolConstants.SYMBOL_MAPFIELD);
                    fields5.Insert(0, mapField);
                    return fields5;

                case (int)RuleConstants.RULE_TYPEFIELD6:
                    //<TypeField> ::= 
                    return new List<PatternBufferField>();

                case (int)RuleConstants.RULE_PRIMITIVEFIELD_SEMI:
                    //<PrimitiveField> ::= <PrimitiveFieldType> <FieldName> ';'
                    string primitiveFieldType = token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_PRIMITIVEFIELDTYPE);
                    string primitiveFieldName = token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_FIELDNAME);
                    return new PatternBufferField(
                        primitiveFieldName,
                        new PrimitiveFieldType((PrimitiveType)Enum.Parse(typeof(PrimitiveType), primitiveFieldType, true))
                    );

                case (int)RuleConstants.RULE_PRIMITIVEFIELDTYPE_PRIMITIVE:
                    //<PrimitiveFieldType> ::= Primitive
                    return token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_PRIMITIVE);

                case (int)RuleConstants.RULE_REFERENCEFIELD_SEMI:
                    //<ReferenceField> ::= <ReferenceFieldType> <FieldName> ';'
                    string referenceFieldType = token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_REFERENCEFIELDTYPE);
                    string referenceFieldName = token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_FIELDNAME);
                    return new PatternBufferField(
                        referenceFieldName,
                        new ReferenceFieldType(referenceFieldType)
                    );

                case (int)RuleConstants.RULE_REFERENCEFIELDTYPE_NAME:
                    //<ReferenceFieldType> ::= Name
                    return token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_NAME);

                case (int)RuleConstants.RULE_FIELDNAME_NAME:
                    //<FieldName> ::= Name
                    return token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_NAME);

                case (int)RuleConstants.RULE_LISTFIELD_LIST_LT_GT_SEMI:
                    //<ListField> ::= list '<' <AggregateArg> '>' <FieldName> ';'
                    string listAggregateArgName = token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_AGGREGATEARG);
                    string listFieldName = token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_FIELDNAME);
                    return new PatternBufferField(
                        listFieldName,
                        new ListFieldType(this.CreateAggregateableFieldType(listAggregateArgName))
                    );

                case (int)RuleConstants.RULE_SETFIELD_SET_LT_GT_SEMI:
                    //<SetField> ::= set '<' <AggregateArg> '>' <FieldName> ';'
                    string setAggregateArgName = token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_AGGREGATEARG);
                    string setFieldName = token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_FIELDNAME);
                    return new PatternBufferField(
                        setFieldName,
                        new SetFieldType(this.CreateAggregateableFieldType(setAggregateArgName))
                    );

                case (int)RuleConstants.RULE_MAPFIELD_MAP_LT_COMMA_GT_SEMI:
                    //<MapField> ::= map '<' <AggregateArg> ',' <AggregateArg> '>' <FieldName> ';'
                    string mapKeyAggregateArgName = null;
                    string mapValueAggregateArgName = null;
                    foreach (Token mapToken in token.Tokens) {
                        if (mapToken is NonterminalToken) {
                            NonterminalToken mapNonterminal = (NonterminalToken)mapToken;
                            if (mapNonterminal.Symbol.Id == (int)SymbolConstants.SYMBOL_AGGREGATEARG) {
                                if (mapKeyAggregateArgName == null) {
                                    mapKeyAggregateArgName = (string)mapNonterminal.UserObject;
                                }
                                else {
                                    mapValueAggregateArgName = (string)mapNonterminal.UserObject;
                                    break;
                                }
                            }
                        }
                    }
                    string mapFieldName = token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_FIELDNAME);
                    return new PatternBufferField(
                        mapFieldName,
                        new MapFieldType(
                            this.CreateAggregateableFieldType(mapKeyAggregateArgName),
                            this.CreateAggregateableFieldType(mapValueAggregateArgName)
                        )
                    );

                case (int)RuleConstants.RULE_AGGREGATEARG:
                    //<AggregateArg> ::= <PrimitiveFieldType>
                    return token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_PRIMITIVEFIELDTYPE);

                case (int)RuleConstants.RULE_AGGREGATEARG2:
                    //<AggregateArg> ::= <ReferenceFieldType>
                    return token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_REFERENCEFIELDTYPE);

                case (int)RuleConstants.RULE_ENUM_ENUM_LBRACE_RBRACE:
                    //<Enum> ::= enum <EnumName> '{' <Hint> <EnumValue> '}'
                    string enumName = token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_ENUMNAME);
                    List<string> enumValues = token.GetUserObjectForSubToken<List<string>>((int)SymbolConstants.SYMBOL_ENUMVALUE);
                    HashSet<string> uniques = new HashSet<string>(enumValues);
                    if (uniques.Count < enumValues.Count) {
                        throw new PatternBufferSchemaException("Enum \"" + enumName + "\" has " + (enumValues.Count -uniques.Count) + " duplicate enum values.");
                    }
                    if (uniques.Count == 0) {
                        throw new PatternBufferSchemaException("Enum \"" + enumName + "\" has no values. Enums must have at least one value.");
                    }
                    Dictionary<string,string> enumHints = token.GetUserObjectForSubToken<Dictionary<string,string>>((int)SymbolConstants.SYMBOL_HINT);
                    return new PatternBufferEnum(
                        enumName,
                        enumValues,
                        enumHints
                    );

                case (int)RuleConstants.RULE_ENUMNAME_NAME:
                    //<EnumName> ::= Name
                    return token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_NAME);

                case (int)RuleConstants.RULE_ENUMVALUE_NAME:
                    //<EnumValue> ::= Name
                    return new List<string>() { token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_NAME) };

                case (int)RuleConstants.RULE_ENUMVALUE_NAME_COMMA:
                    //<EnumValue> ::= Name ',' <EnumValue>
                    List<string> enumValues2 = token.GetUserObjectForSubToken<List<string>>((int)SymbolConstants.SYMBOL_ENUMVALUE);
                    enumValues2.Insert(0, token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_NAME));
                    return enumValues2;

                case (int)RuleConstants.RULE_HINT_LBRACKET_EQ_RBRACKET:
                    //<Hint> ::= '[' <HintName> '=' <HintValue> ']' <Hint>
                    Dictionary<string, string> collectedHints = token.GetUserObjectForSubToken<Dictionary<string, string>>((int)SymbolConstants.SYMBOL_HINT);
                    string hintName = token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_HINTNAME2);
                    string hintValue = token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_HINTVALUE);
                    collectedHints[hintName] = hintValue;
                    return collectedHints;

                case (int)RuleConstants.RULE_HINT:
                    //<Hint> ::= 
                    return new Dictionary<string, string>();

                case (int)RuleConstants.RULE_HINTNAME_HINTNAME:
                    //<HintName> ::= HintName
                    return token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_HINTNAME);

                case (int)RuleConstants.RULE_HINTVALUE_STRING:
                    //<HintValue> ::= String
                    return token.GetUserObjectForSubToken<string>((int)SymbolConstants.SYMBOL_STRING);
            }
            throw new RuleException("Unknown rule");
        }

        /**
         * Listener to set the parse error so it can be surfaced to the caller.
         */
        private void TokenErrorEvent(LALRParser parser, TokenErrorEventArgs args) {
            this.error = "Token error with input: '" + args.Token.ToString() + "'";
        }

        /**
         * Listener to set the parse error so it can be surfaced to the caller.
         */
        private void ParseErrorEvent(LALRParser parser, ParseErrorEventArgs args) {
            this.error = "Parse error caused by token: '" + args.UnexpectedToken.ToString() + "'";
        }

        /**
         * Creates an aggregate field type with the given aggregate arg name. i.e. "list<Whatever>"
         */
        private IAggregateableFieldType CreateAggregateableFieldType(string aggregateArgName) {
            IAggregateableFieldType listAggregateableFieldType = null;

            if (this.lowerCasePrimitiveTypeEnumValues.Contains(aggregateArgName)) {
                listAggregateableFieldType = new PrimitiveFieldType(
                    (PrimitiveType)Enum.Parse(typeof(PrimitiveType), aggregateArgName, true)
                );
            }
            else {
                listAggregateableFieldType = new ReferenceFieldType(aggregateArgName);
            }
            return listAggregateableFieldType;
        }

        /**
         * Dumps the parse tree to the console. Useful for debugging parse issues.
         */
        private void DumpTree(Token token) {
            this.DumpTree(token, "");
        }

        /**
         * Inner method to dump the parse tree to Console.
         */
        private void DumpTree(Token token, string indentation) {
            if (token is NonterminalToken) {
                NonterminalToken nonterminalToken = (NonterminalToken)token;
                Console.WriteLine(indentation + nonterminalToken.Symbol);
                // Delve each subtoken with additional indentation
                foreach (Token subtoken in nonterminalToken.Tokens) {
                    this.DumpTree(subtoken, indentation + "  ");
                }
            }
            else if (token is TerminalToken) {
                Console.WriteLine(indentation + token.ToString());
            }
        }

        /**
         * Helper method to resolve referrables by name
         */
        private IPatternBufferReferrable GetReferrable(
            string referrableName, 
            Dictionary<string, IPatternBufferReferrable> nameReferrableMap
        ) {
            IPatternBufferReferrable result = null;
            if (nameReferrableMap.ContainsKey(referrableName)) {
                result = nameReferrableMap[referrableName];
            }
            else {
                throw new PatternBufferSchemaException("Encountered reference to an unknown type or enum: " + referrableName);
            }
            return result;
        }

        /**
         * Sets the actual referrable type on the referrable object (transforms the name to the actual referrable).
         */
        private void SetReferrable(IFieldType fieldType, Dictionary<string, IPatternBufferReferrable> nameReferrableMap) {
            if (fieldType is ReferenceFieldType) {
                ReferenceFieldType rft = (ReferenceFieldType)fieldType;
                rft.Referrable = this.GetReferrable(rft.ReferrableName, nameReferrableMap);
            }
        }

        /**
         * Validates a type by checking for duplicate types, setting referrables, verifying type hierarchy, 
         * and making sure type names aren't duplicated.
         */
        private void ValidateType(
            PatternBufferType type, 
            Dictionary<string, IPatternBufferReferrable> nameReferrableMap,
            Dictionary<string, PatternBufferType> nameTypeMap,
            Dictionary<string, PatternBufferEnum> nameEnumMap
        ) {

            // Prep the bookkeeping for dupe detection
            List<string> visitedTypeNames = new List<string>() { type.Name };
            List<string> fieldNames = new List<string>() { };

            // Validate the fields
            foreach (PatternBufferField field in type.Fields) {

                // Check for dupes
                if (fieldNames.Contains(field.Name)) {
                    throw new PatternBufferSchemaException("The type " + type.Name + " has a duplicate field name: " + field.Name);
                }
                fieldNames.Add(field.Name);

                // Validate referrables
                if (field.fieldType is ListFieldType) {
                    this.SetReferrable(((ListFieldType)field.fieldType).ElementType, nameReferrableMap);
                }
                else if (field.fieldType is SetFieldType) {
                    this.SetReferrable(((SetFieldType)field.fieldType).ElementType, nameReferrableMap);
                }
                else if (field.fieldType is MapFieldType) {
                    MapFieldType mapFieldType = (MapFieldType)field.fieldType;
                    this.SetReferrable(mapFieldType.KeyType, nameReferrableMap);
                    this.SetReferrable(mapFieldType.ValueType, nameReferrableMap);
                }
                else if (field.fieldType is ReferenceFieldType) {
                    this.SetReferrable(field.fieldType, nameReferrableMap);
                }
            }
            
            // Validate the type hierarchy
            string baseTypeName = type.baseTypeName;
            while (baseTypeName != null) {

                // Check for circuits
                if (visitedTypeNames.Contains(baseTypeName)) {
                    throw new PatternBufferSchemaException("An inheritance circuit exists on type " + type.Name + ".");
                }
                visitedTypeNames.Add(baseTypeName);

                // Check that all types in the type hierarchy exist
                if (!nameTypeMap.ContainsKey(baseTypeName)) {
                    throw new PatternBufferSchemaException("The ancestry of type " + type.Name + " refers a type that doesn't exist: " + baseTypeName);
                }

                PatternBufferType baseType = nameTypeMap[baseTypeName];

                // Check for field name collisions
                foreach (PatternBufferField baseTypeField in baseType.Fields) {
                    if (fieldNames.Contains(baseTypeField.Name)) {
                        throw new PatternBufferSchemaException("The type " + type.Name + " defines a field that is already in its ancestry: " + baseTypeField.Name);
                    }
                    fieldNames.Add(baseTypeField.Name);
                }

                baseTypeName = baseType.baseTypeName;
            }
        }
    }
}
