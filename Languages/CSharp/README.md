# C# PatternBuffer

This is the default implementation of PatternBuffers in C#. 

For usage notes on the pbc-cs.exe command line application, see this related [README](https://tbd/lol).

## Projects

The C# PatternBuffer implementation is comprised of several sub-projects. They are described below.

### PatternBufferCompiler 

The library containing the default C# PatternBufferCompiler class and supporting functions. This is NOT a command line application, but rather just a class that can compile C# PatternBuffers.

### PatternBufferCompilerProgram

This is a command line app wrapping the PatternBufferCompiler. It generates pbc-cs.exe, which is a standalone command line app dependent only on the .NET framework run-time.

### PatternBufferSchema

This contains a parser that can read .pb files, and the domain objects describing the contents of the .pb file. Both are used by the PatternBufferCompiler to ingest .pb schemas. If you want to make your own C# PatternBuffer compiler, this schema library saves you the trouble of parsing the .pb file yourself.

### PatternBufferTest
Exercises the APIs defined in the other libraries. Also generates some code into...

### PatternBufferGeneratedTest 
...which in turn exercises the code generated by the compiler for a few select schema test cases.

## Dependencies

You can see dependencies in the References node of your solution, but here they are, explicitly:

* PatternBufferSchema - None
* PatternBufferCompiler - PatternBufferSchema
* PatternBufferCompilerProgram - PatternBufferCompiler, PatternBufferSchema
* PatternBufferGeneratedTest - None
* PatternBufferTest - PatternBufferCompiler, PatternBufferSchema

## Thread Safety

The pbc-cs.exe command line application offers an option to generate threadsafe code. Generated PatternBuffer classes rely on a singular internal byte buffer to build up serialized objects. The "MakeThreadsafe" option adds lock() statements in key places to ensure a single generated PatternBuffer class doesn't corrupt data while serializing multiple objects simultaneously. In tests, generating lock()ed code incurred a 25%-30% reduction in performance.

As an alternative, consider generating un-threadsafe code, but instantiating multiple copies of your generated PatternBuffer class. You can then use your preferred object pooling technique to increase throughput. This gives you total control over memory and serialization throughput.